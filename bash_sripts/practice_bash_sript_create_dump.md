# Bash example

Своего рода example, но это вполне рабочий скрипт для сборки дампов на сервере из контейнера.
собирает в папку dumps, макс три файла(потом начнет заменять файлы), каждый день в 2 ночи.

## Bash sript dump

Для выполнения вашей задачи можно использовать скрипт на Bash, который будет вызываться через cron. Допустим, у вас есть Docker контейнер с PostgreSQL, и вы хотите регулярно делать дампы базы данных, сохраняя их в определенной папке с ограничением на количество хранимых дампов.

Вот пример такого скрипта:

```bash
#!/bin/bash

# Название контейнера с PostgreSQL
CONTAINER_NAME="your_postgres_container"
# Имя базы данных
DATABASE_NAME="your_database"
# Путь к папке с дампами относительно скрипта
DUMPS_DIR="./dumps"
# Максимальное количество дампов
MAX_DUMPS=3

# Создаем папку для дампов, если она не существует
mkdir -p $DUMPS_DIR

# Формируем имя файла дампа
DUMP_FILE="$DUMPS_DIR/dump_$(date +%Y-%m-%d_%H-%M-%S).sql"

# Создаем дамп базы данных
docker exec $CONTAINER_NAME pg_dump -U postgres $DATABASE_NAME > $DUMP_FILE

# Удаляем старые дампы, если их количество превышает MAX_DUMPS
DUMPS_COUNT=$(ls -1 $DUMPS_DIR/*.sql 2>/dev/null | wc -l)
if [ $DUMPS_COUNT -gt $MAX_DUMPS ]; then
  # Находим самые старые дампы и удаляем их
  ls -1tr $DUMPS_DIR/*.sql | head -n -$MAX_DUMPS | xargs rm -f
fi
```

Чтобы использовать этот скрипт, вам нужно:

1. Заменить ```your_postgres_container``` на имя вашего Docker контейнера с PostgreSQL.
2. Заменить ```your_database``` на имя вашей базы данных.
3. Проверить и при необходимости изменить путь к папке ```DUMPS_DIR```, где будут храниться дампы.
4. Дать скрипту права на выполнение командой ```chmod +x script_name.sh.```

Чтобы добавить этот скрипт в cron для регулярного выполнения, откройте crontab на редактирование командой ```crontab -e``` и добавьте строку, аналогичную приведенной ниже, адаптировав ее под ваш график:

```bash
0 2 * * * /path/to/your/script.sh
```

Эта строка настроит cron на запуск скрипта каждый день в 2:00 ночи. Убедитесь, что указываете полный путь к скрипту.

Обратите внимание, что в примере используется пользователь ```postgres``` для создания дампа. Если у вас другой пользователь или требуется пароль, вам нужно будет соответствующим образом настроить команду ```pg_dump```.

## Запуск сприта ручками

Чтобы запустить написанный вами скрипт вручную, выполните следующие шаги:

1. Откройте терминал на вашем компьютере или сервере, где находится скрипт.

2. Перейдите в директорию, где лежит ваш скрипт, с помощью команды ```cd```. Например, если ваш скрипт находится в директории ```/home/user/scripts```, используйте команду:

```bash
cd /home/user/scripts
```

3. Убедитесь, что у скрипта есть права на выполнение. Вы можете сделать скрипт исполняемым, используя команду ```chmod```. Например, если ваш скрипт называется ```backup_script.sh```, используйте команду:

```bash
chmod +x backup_script.sh
```

4. Запустите скрипт, используя следующую команду:

```bash
./backup_script.sh
```

Убедитесь, что вы используете точку и слэш (```./```) перед именем скрипта, если запускаете его из текущей директории.

После выполнения этих шагов скрипт начнет работу. В зависимости от того, что делает скрипт, вы можете увидеть вывод в терминале или скрипт может работать без видимого вывода. Если в скрипте предусмотрен вывод информации о процессе работы или результате (например, через команды ```echo``` в Bash), вы сможете наблюдать за процессом выполнения.

Если при запуске скрипта возникают ошибки, внимательно проверьте текст ошибок — они могут указывать на проблемы в скрипте или на отсутствие необходимых разрешений. Убедитесь также, что все внешние зависимости (например, доступ к Docker, базе данных и т.д.) настроены корректно.

## Вывод инфы в stout

Чтобы выводить информацию в стандартный вывод (stdout) из Bash скрипта, вы можете использовать команду echo или printf. Эти команды позволяют отображать текстовые сообщения, которые могут информировать пользователя о текущем шаге выполнения скрипта, выводить значения переменных или любую другую полезную информацию.

### Использование echo

Команда ```echo``` — это один из самых простых и часто используемых способов для вывода текста в Bash скриптах.

Пример:

```bash
#!/bin/bash

echo "Начало работы скрипта"

# Ваш код здесь
echo "Выполняется шаг 1..."
# Код шага 1

echo "Выполняется шаг 2..."
# Код шага 2

echo "Скрипт завершен."
```

### Использование printf

```printf``` предоставляет больше возможностей по сравнению с ```echo```, включая форматирование вывода. Однако его синтаксис немного сложнее.

Пример:

```bash
#!/bin/bash

printf "Начало работы скриптаn"

# Ваш код здесь
printf "Выполняется шаг 1...n"
# Код шага 1

printf "Выполняется шаг 2...n"
# Код шага 2

printf "Скрипт завершен.n"
```

В обоих примерах после каждого сообщения используется символ новой строки ```n```, чтобы следующее сообщение начиналось с новой строки.

### Вывод переменных

Чтобы вывести значение переменной, используйте ```$имя_переменной``` в команде ```echo``` или ```printf```.

Пример с ```echo```:

```bash
#!/bin/bash

user="Имя пользователя"
echo "Текущий пользователь: $user"
```

Пример с ```printf```:

```bash
#!/bin/bash

user="Имя пользователя"
printf "Текущий пользователь: %sn" "$user"
```

Использование ```echo``` или ```printf``` для вывода информации в stdout позволяет сделать выполнение скрипта более прозрачным и информативным для пользователя.

## ENV и переменные

Вы можете использовать переменные окружения, заданные в файле ```.env```, в вашем Bash скрипте. Для этого сначала необходимо загрузить переменные из файла ```.env``` в окружение скрипта. Один из способов сделать это — использовать команду ```source``` (или её синоним .) перед выполнением основной части скрипта.

Предположим, у вас есть файл .env со следующим содержанием:

```bash
CONTAINER_NAME=ncpti_db
DATABASE_NAME=ncpti
```

В вашем Bash скрипте вы можете загрузить эти переменные следующим образом:

```bash
#!/bin/bash

# Загрузка переменных из файла .env


if [ -f .env ]; then
    export $(cat .env | xargs)
fi

# Теперь переменные CONTAINER_NAME и DATABASE_NAME доступны в скрипте
echo "CONTAINER_NAME: $CONTAINER_NAME"
echo "DATABASE_NAME: $DATABASE_NAME"

#  Ваш код далее...
```

Команда ```export $(cat .env | xargs)```
выполняет следующие действия:

- ```cat .env``` читает содержимое файла ```.env```.
- ```xargs``` преобразует каждую строку входных данных в аргументы команды.
- ```export``` делает эти переменные доступными как переменные окружения для текущего сеанса оболочки и для любых процессов, запущенных из оболочки.

Обратите внимание, что этот метод предполагает, что ваш файл ```.env``` содержит переменные в формате ```KEY=value``` без пробелов вокруг знака равенства и без экспорта в каждой строке. Также стоит быть осторожным с безопасностью, особенно если ваши переменные окружения содержат чувствительные данные, так как использование ```export $(cat .env | xargs)``` может быть уязвимо в некоторых контекстах.

## Работа с переменными из .env

Конечно, если вам не нужно выводить значения переменных в стандартный вывод, просто уберите команды echo, которые выводят эти значения. Вам всё равно нужно будет загрузить переменные из файла ```.env```, чтобы они были доступны в вашем скрипте, но после загрузки не обязательно их печатать.

Вот как выглядит скрипт, который загружает переменные из .env, но не выводит их значения:

```bash
#!/bin/bash

# Загрузка переменных из файла .env
if [ -f .env ]; then
    export $(grep -v '^#' .env | xargs)
fi

# Теперь переменные CONTAINER_NAME, DATABASE_NAME и PG_USER доступны в скрипте
# Ваш код далее...
```

В этом примере я также добавил ```grep -v '^#'```, чтобы игнорировать строки, начинающиеся с символа ```#```, которые обычно используются для комментариев в файлах ```.env```.

Теперь, когда вы запустите этот скрипт, он загрузит переменные из ```.env``` в окружение скрипта, но не будет выводить их значения. Вы можете использовать эти переменные в любом месте вашего скрипта, как обычные переменные окружения, например, при вызове команд Docker или в других операциях скрипта.

## Finish

```bash
#!/bin/bash
echo "Создание дампа. Начала работы."

# Загрузка переменных из файла .env
if [ -f .env ]; then
    export $(grep -v '^#' .env | xargs)
fi

# Путь к папке с дампами относительно скрипта
DUMPS_DIR="./dumps"
# Максимальное количество дампов
MAX_DUMPS=3

# Создать папку для дампов, если она не существует
mkdir -p $DUMPS_DIR

# Сформировать имя файла дампа
DUMP_FILE="$DUMPS_DIR/dump_$(date +%Y-%m-%d_%H-%M-%S).sql"

# Создать дамп базы данных
docker exec $CONTAINER_NAME pg_dump -U $PG_USER $DATABASE_NAME > $DUMP_FILE

# Удалить старые дампы, если их количество превышает MAX_DUMPS
DUMPS_COUNT=$(ls -1 $DUMPS_DIR/*.sql 2>/dev/null | wc -l)
if [ $DUMPS_COUNT -gt $MAX_DUMPS ]; then
  # Находим самые старые дампы и удаляем их
  ls -1tr $DUMPS_DIR/*.sql | head -n -$MAX_DUMPS | xargs rm -f
fi
```
