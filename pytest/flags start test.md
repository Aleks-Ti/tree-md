# CLI pytest

## Навигация

- [Флаги при запуске `-v, -vv, -q`](#флаги-при-запуске-тестов-и-отображение-отчетов-по-результатам)
- - [-v](#краткий-вывод-результатов-pytest--v)
- - [-vv](#более-подробный-вывод-информации-о-тестах-pytest--vv)
- - [-q](#тихий-режим-pytest--q)
- [Выборочный запуск тестов](#выборочный-запуск-тестов)
- [Запуск упавших тестов + Кэш](#запуск-упавших-тестов-кеш-pytest)
- [Последовательное выполнение тестов](#поэтапное-выполнение-тестов-stepwise)

## Флаги при запуске тестов и отображение отчетов по результатам

### Краткий вывод результатов `pytest -v`

pytest с ключом `-v`, то информация о каждой тестирующей функции будет выведена отдельной строкой. У этого ключа есть и полная форма — `--verbose` (англ. «подробно», «многословно»).

```toml
test_example.py::test_correct PASSED                                      [ 50%] 
test_example.py::test_fail FAILED                                         [100%]
```

### Более подробный вывод информации о тестах `pytest -vv`

Запуск тестов с ключом -vv делает отчёт ещё подробнее и позволяет увидеть все отличия, без сокращений.

### Тихий режим `pytest -q`

`-q` (полная форма `--quiet` — «тихо»). При запуске тестов с этим ключом детализация отчёта уменьшится; например, будет скрыт этот фрагмент служебной информации:

```yml
======================= test session starts =========================
platform win32 -- Python 3.9.13, pytest-7.1.2, pluggy-1.0.0
rootdir: <путь до вашего проекта>
collected 2 items
```

## Выборочный запуск тестов

- Для выборочного запуска в pytest применяется такой синтаксис:

```bash
pytest file_name.py::TestClassName::test_method_name
```

- Чтобы выполнить все тесты из отдельного файла — обращаемся к нему по имени файла:

```bash
pytest file_name.py
```

- По Node ID `file_name.py::TestClassName` запустятся все тесты из класса `TestClassName` в файле `file_name.py`:

```bash
pytest file_name.py::TestClassName
```

- Если тесты представлены функциями, а не классами, то можно запускать отдельные тесты следующим образом:

```bash
pytest test_example.py::test_fail
```

- Можно запустить сразу несколько тестов, перечислив их Node ID через пробел:

```bash
pytest test_example.py::test_fail test_example.py::test_correct
```

- Если в проекте есть несколько директорий с тестами — можно запустить тесты в любой из них (или в нескольких, указав их через пробел):

```bash
pytest pytest_trial
```

- Если тесты находятся в разных директориях, то в `Node ID` нужно указать имя директории, где лежит тест.

```bash
pytest pytest_trial/test_example.py
```

Названия файлов в разных директориях могут повторяться; чтобы избежать конфликтов имён — в каждой директории с тестами должен быть файл __init__.py.

- При запуске тестов можно не указывать `Node ID` теста, а применить ключ `-k`: он позволяет запускать тесты по частичному совпадению имени файла, имени класса или тестирующей  функции:

```bash
pytest -k "correct"
```

По этой команде будут запущены те тесты, в `Node ID` которых есть слово `“correct”` — например, тесты с именами `test_correct()`, `testcorrect()` и `test_not_correct()`.

- Ключ `-k` можно применить иначе: в параметре этого ключа можно указать, `какие тесты не должны запускаться`. Для этого применяется ключевое слово `not`.

```bash
pytest -k "not correct"
```

### Помимо not для работы с ключом -k можно использовать и конструкции с ключевыми словами and и or; можно применять скобки

```bash
pytest -k "(django or python) and not javascript"
```

При выполнении такой команды будут запущены все тесты, в Node ID которых есть слова “django” или “python”, но при этом не будет слова “javascript”.

## Запуск упавших тестов. Кеш pytest

После выполнения тестов в директории .pytest_cache/ сохраняется список провалившихся тестов, и при следующем тестировании можно запустить лишь те тесты, которые в прошлый раз вернули ошибку.

- при запуске тестов с ключом `--lf` (он же `--last-failed`) будут выполнены только те тесты, которые провалились в прошлый раз

- при запуске тестов с ключом `--ff` (он же `--failed-first`) сначала будут выполнены провалившиеся тесты, а после них — все остальные. Полезный способ для ситуаций, когда исправление одной ошибки могло повлечь возникновение другой

- Можно запустить тесты так, что сначала выполнятся `новые — те, о которых нет записей в кеше`, а после них — все остальные. Для этого надо выполнить команду `pytest с ключом --nf` (он же --`new-first`). При этом «старые» тесты будут выполняться `в порядке «сначала новые, потом старые»`, в зависимости от даты модификации файлов с тестами.

- Один из самых полезных ключей в pytest — это `-x` (он же `--exitfirst`): «остановить выполнение тестов ``при первом же падении``». Если хотя бы один тест упал — значит, что-то не в порядке, и надо разбираться с кодом, а не ждать, пока будут пройдены все тесты.

`pytest --ff -x`: «начать с провалившихся тестов и остановиться при первом же падении теста».

- Выполнение тестов можно останавливать не только после первого падения, но и после провала любого другого количества тестов. Количество можно указать в ключе `--maxfail=N`, где `N` — число проваленных тестов. Например, при запуске тестов с ключом `--maxfail=3` выполнение остановится после падения трёх тестов.

## Поэтапное выполнение тестов: stepwise

Режим `stepwise` (запуск с ключом `--sw` или `--stepwise`) — это пошаговое выполнение тестов, при котором можно «фиксить» проблемы по очереди.

При запуске тестов с ключом `--sw` тесты выполняются до тех пор, пока один из них не упадёт; после падения выполнение тестов останавливается (точно как с ключом `-x`). После этого можно поправить код и снова запустить тесты с ключом `--sw`; выполнение начнётся с упавшего теста и продолжится дальше.

Этот режим чем-то похож на комбинацию ключей `--lf -x`: «запустить все провалившиеся тесты и остановиться на первом упавшем». Но у режима `stepwise` есть полезная особенность: если не удаётся решить проблему с каким-то падающим тестом — его можно пропустить и перейти к следующему. Делается это при помощи ключа `--stepwise-skip`. Непокорный тест будет пропущен, и больше в этом поэтапном режиме он появляться не будет, выполнение тестов пойдёт дальше.

### print() в тесте

```python
# test_example.py
def one_more(x):
    return x + 1


def test_correct():
    print('Правильный тест')  # Новая строка.
    assert one_more(4) == 5


def test_fail():
    print('Неправильный тест')  # Новая строка.
    assert one_more(3) == 5


...  # Остальное содержимое файла.
```

Примерный перевод фразы Captured stdout call — это «Захваченный поток вывода»; `stdout` — это стандартный поток вывода (попросту — данные, которые выводятся в терминал). `Pytest перехватывает все данные`, которые предназначены для вывода в консоль — `и показывает в терминале stdout данные только из провалившихся тестов`; остальной поток вывода в консоли не отображается.

При отладке это неудобно, ведь хочется понять, как ведёт себя функция и при успешном прохождении теста, и при его провале.
Перехват потока вывода можно отключить: для этого тесты запускают с ключом `-s` (другой вариант — `--capture=no`). Выполните команду `pytest -s -k "correct or fail"`.

```bash
test_example.py Правильный тест
.Неправильный тест
F
```

Есть пара вариантов получше. Во-первых, можно запустить тесты с ключом `-v` — вывод расширенного отчёта. Запустите тесты с ключами `-v` и `-s`: `pytest -v -s -k "correct or fail"`.

```bash
test_example.py::test_correct Правильный тест
PASSED
test_example.py::test_fail Неправильный тест
FAILED
```

Ещё один вариант — вывести дополнительную информацию после всех тестов. Делается это при помощи ключа `-rP`, в котором буква `r` обозначает вывод дополнительной информации (`show extra test summary info`), а заглавная буква `P` указывает на успешно пройденные тесты с выводом данных (`Passed with output`).
Запустите команду pytest `-rP -k "correct or fail"`.

```bash
=========================== FAILURES ============================ 
___________________________ test_fail ___________________________ 

<Здесь информация о проваленном тесте>

--------------------- Captured stdout call ---------------------- 
Неправильный тест
============================ PASSES ============================= 
_________________________ test_correct __________________________ 
--------------------- Captured stdout call ---------------------- 
Правильный тест
```

Таким образом, когда нужно вывести в терминал результат работы `print()` из успешно пройденных тестов, используйте любой понравившийся вариант:

- `pytest -s`;
- `pytest -s -v`;
- `pytest -rP`;
