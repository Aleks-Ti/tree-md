# Операционная система и устройство. Базовое представление

- Операционная система состоит из `User space` - т.е. пространство пользователя.
- `Cernel space` пространство ядра

## User space

К нему относится, различный `приложения`: `bash`, `redis`, `vim`...
Разные `демоны`: `systemd`, `networkd`
Библиотеки: `Gtk`, `Qt`, `zlib`

## Cernel space

- Входит всё что взаимодействует с ядром операционном системы:
- - Службы управление памятью
- - Службы управления процессами
- - Файловая система
- - Сетевая подсистема
- - Системные вызовы: `open`, `read`, `fork`

## Между User space и Cernel space

Ос не существует в вакууме. `User space` общается с `Cernel space` посредством вызовов стандартной библиотеки `C` (`glib, muscl, bionic`), и крутится всё это (связующая библа и cernel и user spaces) на железе (`CPU. память, диски`)


## Устройство памяти

Физическая память разделена на страницы, и часть из этих страниц, занята `ядром`, часть занята `процессами`, остальное свободно.

Для удобства работы с памятью, интерфейс ОС предоставляет возможность работать с `виртуальной памятью` для каждого процесса.

Для того что бы связать адреса `виртуальной памяти` с адресами `физической памятью`, используется `таблица страниц`

```bash
Страницы виртуальной памяти процесса №1                       Страницы физической памяти
|_____________________________________|                       |_________________________|
|занято ядром                         |     _____________     |занято ядром             |
|занято процессом                     |    |Таблица      |    |занято процессом         |
|свободно                             |----|    страниц  |----|свободно                 |
|свободно                             |    |             |    |занято процессом         |
|...                                  |    |_____________|    |...                      |
|свободно                             |                       |занято процессом         |
```

Если у нас не находится нужная запись в физической памяти, то происходит `page fault`

- Page fault бывают:
- - Легкий(minor) отказы страницы - нужно только добавить запись в таблицу страниц
- - Значительный(major) отказ страницы - нужно найти свободную страницу и загрузить в нее данные, перед обновлением таблицы страниц

### Виртуальная память

***

- Виртуальная память, состоит:
- - Пространство ядра(1гб)
- - Пространство процесса(3гб)

***

- Приемущества виртуальной памяти:
- - Защита памяти процесса и ядра от несанкционированного доступа
- - Поддержка памяти только для чтения(например в области есть какая то библиотека, так мы можешь защитить свою память от записи и тп, отдав только на чтения - бывает удобно)
- - Разделение памяти между множеством процессов и ядром (позволяет экономить память)
- - Выгрузка давно не используемых страниц на диск (свопинг)
- - Подержка разделяемой между процессами памяти и copy-on-write

***

- Память сегментируется следующим образом:
- - `Пространство Ядра`
- - (далее идёт случайное смещение памяти (защита от атак на адреса памяти))
- - `Стек`
- - (далее идёт случайное смещение памяти (защита от атак на адреса памяти))
- - `Memory mapping` - позволяет загружать данные из файлов и ускорять таким образом ввод-вывод
- - `Heap`(Куча) - предназначена для хранения данных динамических данных приложения
- - (далее идёт случайное смещение памяти (защита от атак на адреса памяти))
- - `Остальное` - статические переменные, код (код нашей программы)

## Управление процессами

- `Процесс` - это запущенная программа.
- Процесс, который запускат другой процесс, называется `родительским`, а созданный - `дочерним`
- Все запущенные процессы образуют `дерево процессов`.

***

Допустим у нас есть процесс для приложения на Python(родительский), и внутри кода можно создать новый `процесс`(дочерний) для этого используется системный вызов `fork()` - при этом появляется `точная копия родительского процесса со своим id`, и нужно учитывать, что дочерний процесс начинается исполняться `ровно с того места, с которого был вызван`.
При этом `родительский` занимается своими делами, пока `Child process` исполняется, затем в дочернем процессе выполняет полезную работу, например `exec()`, за ним следует по завершению работы > `exit()`  - выход, и передает системные данные, которые можно получить в `родительского процесса` с помощью команды `wait()`
