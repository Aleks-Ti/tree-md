# Разграничение статики

## Навигация

- [Дефолтный способ без учета бэка и тп](#дефолтный-примитив-с-разграничением-правд-доступа-на-статику)
- [Для работы с бэком и тп, когда есть сеть контейнеров, и бэк отвечает за доступы](#норм-способ-при-работе-с-бэком-и-тп-когда-фул-приложение-и-куча-контейнеров-крутится)

### Дефолтный примитив с разграничением правд доступа на статику

- Вопрос:
- - Как nginx - ом разграничить права доступа на статику? К примеру есть примитивно, open статика и closed, как nginx - ом разграничивать доступы и если статика в volumes лежит?
В целом volumes должно быть несколько, к пример private-static/ и public-static/ но как на входе это разделить?
На уровне приложения, как бы все просто, есть токены, есть инфа про юзера, там все данные и права. А в случае с тем что nginx раздает статику, получается до бэка запрос даже не долетает, а напряму за статикой идет запрос.

- Ответ:
- - Разграничение доступа к статическим файлам в Nginx
Для разграничения доступа к статическим файлам в Nginx, можно использовать директивы location и настройки доступа на уровне конфигурации сервера. В вашем случае, когда есть открытая и закрытая статика, можно настроить два разных location блока для каждой категории файлов.

Пример конфигурации.

1. Открытая статика:

```nginx
location /public-static/ {
    alias /path/to/public-static/;
    autoindex on;
}
```

2. Закрытая статика:

```nginx
location /private-static/ {
    alias /path/to/private-static/;
    auth_basic "Restricted Content";
    auth_basic_user_file /etc/nginx/.htpasswd;
}
```

- В этом примере:
- - Открытая статика доступна всем пользователям без ограничений.
Закрытая статика защищена базовой аутентификацией. Файл .htpasswd должен содержать пары логин/пароль для доступа.

Создание файла ```.htpasswd```
Для создания файла .htpasswd можно использовать утилиту htpasswd:

```bash
htpasswd -c /etc/nginx/.htpasswd username
```

Вас попросят ввести пароль для указанного пользователя.
Разделение статики в volumes
Если статика лежит в разных volumes, например, private-static/ и public-static/, то в конфигурации Nginx нужно указать правильные пути к этим директориям с помощью директивы alias.
Пример конфигурации с volumes:

```nginx
http {
    server {
        listen 80;

        location /public-static/ {
            alias /mnt/volumes/public-static/;
            autoindex on;
        }

        location /private-static/ {
            alias /mnt/volumes/private-static/;
            auth_basic "Restricted Content";
            auth_basic_user_file /etc/nginx/.htpasswd;
        }
    }
}
```

Заключение
Таким образом, вы можете разграничить доступ к статическим файлам в Nginx, используя директивы location и настройки аутентификации. Это позволяет контролировать доступ к различным категориям статики, не пропуская запросы к бэкенду.

### Норм способ при работе с бэком и тп, когда фул приложение и куча контейнеров крутится.

- Вопрос:
- - Да, но бэкенд приложения использует токены в куки, как тогда быть, не заставлять же пользователя пррежде чем забрать статику вводить логин пароль? И как организовать запись тогда токенов или чего там в /etc/nginx/.htpasswd с бэка, ведь не могу же я ручками каждый раз добавлять пользователя в файл.

- Ответ:
- - Разграничение доступа к статическим файлам с использованием токенов
Если ваше приложение использует токены в куки для аутентификации, то можно настроить Nginx так, чтобы он проверял наличие и валидность этих токенов перед предоставлением доступа к закрытой статике. Это можно сделать с помощью модуля ngx_http_auth_request_module, который позволяет Nginx выполнять запросы к бэкенду для проверки аутентификации.

- Пример конфигурации
- - Настройка бэкенда для проверки токенов:
- - - Создайте эндпоинт в вашем бэкенде, который будет проверять токены и возвращать соответствующий HTTP статус (200 для успешной аутентификации, 401 или 403 для отказа)

```python
# Пример на Python (Flask)
from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route('/auth', methods=['GET'])
def auth():
    token = request.cookies.get('auth_token')
    if validate_token(token):
        return '', 200
    else:
        return '', 401

def validate_token(token):
    # Логика проверки токена
    return token == "valid_token"

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

- - Настройка Nginx для использования auth_request:
- - - Включите модуль auth_request и настройте его для проверки токенов через ваш бэкенд

```nginx
http {
    server {
        listen 80;

        location /public-static/ {
            alias /mnt/volumes/public-static/;
            autoindex on;
        }

        location /private-static/ {
            alias /mnt/volumes/private-static/;
            auth_request /auth;
        }

        location = /auth {
            internal;
            proxy_pass http://backend_server:5000/auth;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}
```

- Объяснение
- - Бэкенд для проверки токенов: Создайте эндпоинт /auth, который проверяет токены из куки и возвращает статус 200, если токен валиден, и 401, если нет.
- - Nginx конфигурация:
- - - location /public-static/ предоставляет доступ к открытой статике.
- - - location /private-static/ использует директиву auth_request для проверки токенов через эндпоинт /auth.
- - - location = /auth является внутренним эндпоинтом, который перенаправляет запросы на бэкенд для проверки токенов.

Заключение
Таким образом, вы можете использовать токены в куки для разграничения доступа к статическим файлам в Nginx, не заставляя пользователей вводить логин и пароль каждый раз. Это позволяет эффективно управлять доступом к закрытой статике, используя существующую систему аутентификации вашего приложения.

### Подробности конфига для проверки из пункта -> [Способ разделения статики с бэком](#норм-способ-при-работе-с-бэком-и-тп-когда-фул-приложение-и-куча-контейнеров-крутится)

- Вопрос:
- - Подробонее про location /private-static/ использует директиву auth_request для проверки токенов через эндпоинт /auth.
Там получается эндпоинт location /private-static/ пойдет доставать статику для пользователя, только если вернет 200 от дериктивы auth_request /auth.

- Ответ:
- - Подробное объяснение директивы auth_request в Nginx
Директива auth_request в Nginx используется для проверки аутентификации перед тем, как предоставить доступ к защищенным ресурсам. В этом случае, это означает, что Nginx будет отправлять запрос к эндпоинту /auth для проверки токена, и только если этот эндпоинт вернет статус 200, пользователь получит доступ к статическим файлам в /private-static/.

- Как это работает
- 1. Запрос пользователя:
- - - Пользователь делает запрос к защищенному ресурсу, например, /private-static/somefile.jpg.
- 2. Проверка аутентификации:
- - - Nginx перенаправляет запрос к внутреннему эндпоинту /auth для проверки токена.
- - - Эндпоинт /auth проверяет токен, который находится в куки или заголовке запроса.
- 3. Ответ от эндпоинта /auth:
- - - Если эндпоинт /auth возвращает статус 200, Nginx предоставляет доступ к запрашиваемому ресурсу.
Если эндпоинт /auth возвращает статус 401 или 403, доступ к ресурсу будет запрещен.

Пример конфигурации Nginx

```nginx
http {
    server {
        listen 80;

        location /public-static/ {
            alias /mnt/volumes/public-static/;
            autoindex on;
        }

        location /private-static/ {
            alias /mnt/volumes/private-static/;
            auth_request /auth;
        }

        location = /auth {
            internal;
            proxy_pass http://backend_server:5000/auth;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}
```

- Объяснение конфигурации
- - location /public-static/: Этот блок предоставляет доступ к открытой статике без ограничений.
- - location /private-static/: Этот блок защищает доступ к закрытой статике с помощью директивы auth_request.
- - - auth_request /auth: Эта директива указывает Nginx отправлять запрос к эндпоинту /auth для проверки аутентификации.
- - location = /auth: Этот блок конфигурирует внутренний эндпоинт для проверки токенов.
- - - internal: Указывает, что этот эндпоинт не доступен извне, только для внутренних запросов Nginx.
- - - proxy_pass http://backend_server:5000/auth: Перенаправляет запросы на бэкенд сервер для проверки токенов.
- - - proxy_set_header ...: Устанавливает заголовки для проксируемых запросов.

Заключение

Таким образом, используя директиву ```auth_request```, вы можете настроить Nginx для проверки токенов перед предоставлением доступа к защищенным статическим файлам. Это позволяет интегрировать существующую систему аутентификации вашего приложения с Nginx, обеспечивая безопасность и удобство для пользователей.
