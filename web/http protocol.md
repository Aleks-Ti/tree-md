# HTTP

## Навигация

- [Структура сообщения](#структура-сообщения)
- - [Стартовая строка](#стартовая-строка)
- [HTTP методы запросов](#методы)
- [Заголовки в запросах](#заголовки)
- - [Заголовки запроса](#заголовок-запроса)
- - [Заголовки ответа](#заголовок-ответа)
- [Тело запроса](#тело)
- [Коды ответов](#коды-ответов)

## Структура сообщения

```yml
+   Request             +   Response
+------------------------------------------------+
+   Стартовая строка    +   Строка статуса
+   Заголовки           +   Заголовки
+   Пустая строка       +   Пустая строка
+   Тело                +   Тело
+------------------------------------------------+
```

### Стартовая строка

- Отличия версий протоколов
- - HTTP/1 текстовая версия протокола
- - HTTP/2 бинарная версия протокола

```ruby
$ curl -v https://ya.ru/ping  
> GET/ping HTTP/2  # эндпоинт в который пришел запрос
...
> HTTP/2 404  # версия протокола
...
```

## Методы

- HTTP-метод запроса определяет, что следует сделать:
- - GET получает ресурсы;
- - POST создаёт ресурс;
- - PUT заменяет существующий ресурс целиком;
- - PATCH частично изменяет существующий ресурс;
- - DELETE удаляет ресурс.
- Реже применяют ещё два метода:
- - HEAD получает только заголовки ответа. HEAD похож на GET, но в ответе на этот запрос есть только заголовок, а тела ответа нет.
- - OPTIONS получает перечень HTTP-методов, которые поддерживает сервер.

```ruby
+   Метод   +   Тело Запроса     +   Тело Ответа   +   Идемпотентен   +   Read-only
+---------------------------------------------------------------------------------------+
+   CONNECT +  Не рекомендуется  +   Есть          +    Нет           +     Нет
+   DELETE  +  Не рекомендуется  +   Есть          +    Да            +     Нет
+   GET     +  Не рекомендуется  +   Есть          +    Да            +     Да
+   HEAD    +  Не рекомендуется  +   Нет           +    Да            +     Да
+   OPTIONS +  Не рекомендуется  +   Есть          +    Да            +     Да
+   PATCH   +   Есть             +   Есть          +    Нет           +     Нет
+   POST    +   Есть             +   Есть          +    Нет           +     Нет
+   PUT     +   Есть             +   Есть          +    Да            +     Нет
+   TRACE   +   Нет              +   Есть          +    Да            +     Да
+---------------------------------------------------------------------------------------+
```

Подробнее >> [Идемпотентность](#идемпотентность-и-безопасность-методов)

- Основные запросы:
- - GET, POST, PUT, PATCH, DELETE

## Заголовки

- Виды заголовков Запроса/Ответа

### Заголовок запроса

```http
accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
accept-encoding: gzip, deflate, br
accept-language: ru,en;q=0.9,is=0.8
cache-control: no-cache
cookie: SECRET
refer: https://yandex.ru
user-agent: Mozila/5.0/(X11;Linux x86_64)AppleWebKit/537.36(KHTML, like Gecko) Chrome/110.0.0.0 YaBrowser/23.31.840(beta) Yowser/2.5 Safari/537.36
```

- accept >> какой формат ответа мы ожидаем/устроит. В каком виде мы хотим видеть ответ от него.
- accept-encoding >> Так инфа о кодировках и языках, в которых наш браузер готов отрисовать ответ.
- accept-language >> Инфа о языках, в которых наш браузер готов отрисовать ответ. Можно задать приоритет, типо коэффициент ```ru,en;q=0.9,is=0.8``` если сайт мультичзычен, то он в первую очередь отдасть ответ на этом языке, а второстепенный язык браузер попросит английский. Но если он не может ответить на одном из указанных языков, он ответит на своем, какой есть
- cache-control >> Клиент(браузер) сообщает серверу, хотел бы он кешировать свой запрос, да или нет.
- cookie >> как правило лежат данные от сайта и тп.
- refer >> С какого сайта, я перешел на этот сайт
- user-agent >> C какого устройства, с какого браузера, в общем откуда запрос пришел. (Например можно зашарить, человек, сервер или робот это был)

### Заголовок ответа

```http
accept-ch: Viewport-Width,DRP,Device-Memory,RTT,Downlink,ECT
accept-ch-lifetime: 31536000
cache-control: no-cache,no-store,max-age=0,must-revalidate
content-encoding: br
content-type: text/htmll charset=UTF-8
date: Tue, 17 May 2024 19:28:36 GMT
expires:  Tue, 17 May 2024 19:28:37 GMT
last-modified:  Tue, 17 May 2024 19:28:37 GMT
set-cookie: SECRET
status: 200
x-requestid: 1664479716471331-3381410595086230351-via1-0467-via-I7-balancer-8080-BAL-9691
```

- accept-ch >> Сообщает о том, что готовы принимать с клиента.
- accept-ch-lifetime >> Так инфа о кодировках и языках, в которых наш браузер готов отрисовать ответ.
- cache-control >> Мы сообщили, что мы не хотим кешировать
- Если передаем или принимаем какое то тело, то мы должны передать, в каком формате оно кодируется
- - content-encoding >> Сообщаем что кодировка в формате ```br```. Подробнее >> [content-encoding: br](#content-encoding-br-в-http-ответах)
- - content-type >> Сообщаем что ответ в формате html
- date >> Когда пришел ответ
- expires >> Когда данные страничка перестанет быть валидной/актуальной.  ```если бы существовала какая нить политика кэширование, то можно было бы указать, что данный ответ будет валидным еще где то час например```.
- last-modified >> когда последний раз данные были изменены
- set-cookie >> сервер может сказать, что может какие то куки проставить клиенту, и браузер ее запомнит, если есть значения. Браузеры автоматически берут данные из ответа, и сохраняют себе в куки.
- status >> код статуса ответа
- x-requestid >> Прификс ```x-``` добавляют как правило к кастомным заголовкам, чисто договорённость чтобы отличить системные хэдеры от кастомных. Кастомный заголовок, можно всунуть по какой либо договоренности с фронтом например.

- Еще есть такой хэдер, как ```location```, если он есть в совместке с кодом ответ ```302```(redirect), то браузер автоматически перенаправляет пользователя по указанному адресу.

Пример:

```ruby
$ curl -v https://url_shortener.ru/ad67befb-da91-4c3b-8a92-957b49261594  
> Host:yandex.ru
> User-Agent: curl/7.58.0
> Accept: */*
>
< HTTP/2 302  # пришел ответ
< location: https://example.com/
< date: Tue, 17 May 2024 19:28:36 GMT
< x-yandex-req-id: 1664482461504836-18213635360057874106-vla1-4519-vla-l7-balancer-8080-BAL-9698
< cache-control: max-age=1209600,private
<
```

## Тело

- Тело как правило, может быть что угодно. Главное указать в заголовках, про типы данных

## Коды ответов

```yml
+   Основные типы
+-------------------------+
+   1xx - информационные
+   2xx - успех
+   3xx - перенаправление
+   4xx - ошибки клиента
+   5xx - ошибка сервера
+-------------------------+
```

## Сноски

### Content-Encoding: br в HTTP-ответах

```html
Content-Encoding: br означает, что содержимое ответа сжато с помощью алгоритма сжатия Brotli. Brotli - это современный алгоритм сжатия, специально разработанный для эффективного сжатия контента в HTTP-трафике. Он был определен в RFC 7932 и поддерживается всеми современными браузерами.
Brotli обеспечивает более высокую степень сжатия по сравнению с традиционными алгоритмами, такими как gzip и deflate. Например, Brotli может сжимать JavaScript-файлы на 14% меньше, чем gzip, HTML-файлы - на 21% меньше, а CSS-файлы - на 17% меньше.
Использование Brotli вместо gzip или deflate позволяет уменьшить объем передаваемых данных, что ведет к более быстрой загрузке страниц и снижению расходов на CDN. Поэтому многие современные веб-сайты и сервисы стараются использовать Brotli для сжатия своего контента.
Чтобы использовать Brotli, клиент (например, браузер) должен отправлять в заголовке Accept-Encoding значение "br", а сервер должен поддерживать Brotli и возвращать ответ с заголовком Content-Encoding: br
```

### Идемпотентность и безопасность методов

```html
У HTTP-методов есть две важные характеристики — безопасность и идемпотентность. 
Безопасность: метод, который не изменяет ресурс, называется безопасным. Например, если в качестве ресурса рассматривать никнеймы пользователей, то сколько ни отправляй GET-запрос на получение никнейма конкретного пользователя — к изменению никнейма это не приведёт. Метод GET — безопасный.
Метод, который может изменить ресурс, в терминах архитектуры REST считается небезопасным. Такими методами могут быть PUT, PATCH, DELETE или POST.
Идемпотентность (от лат. idem — «тот же самый» и potens — «способный») — это свойство, заключающееся в том, что многократное выполнение этого метода по результату равно однократному. То есть, выполняя один и тот же запрос много-много раз, мы всегда будем получать один и тот же результат. Даже если сто раз отправить GET-запрос на получение никнейма конкретного пользователя, ответ не изменится; он будет таким же, как если бы его отправили всего лишь один раз. Метод GET — идемпотентный.
А вот метод POST работает иначе: обычно это создание новой записи, например добавление никнейма, независимо от того, есть уже аналогичный никнейм или нет. Если десять раз послать один и тот же POST-запрос, то будет добавлено десять идентичных никнеймов. Метод POST — неидемпотентный.
```
